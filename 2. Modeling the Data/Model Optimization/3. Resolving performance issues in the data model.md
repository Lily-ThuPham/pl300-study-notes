# Many-to-many relationships and their problem
Many-to-many relationships in data model con contribute to performance issues via the following factors:
- The complexity of the data model: Many-to-many relationships inherently add to the complexity of the data model, which can affect performance.
- The use of bi-directional filters: While bi-directional filters can increase complexity and cause performance issues, the core concern is the added intricacy they introduce to the data model.
- The presence of large volumes of data: When handling large amounts of data in many-to-many relationships, performance issues can become more evident
However, calculated columns might contribute to slow performance  
## Applying "Single" Cross Filter Direction 
- **Limited Filter Flow:** This setting restricts filters to flow in only one direction between two related tables.
- **Reduced Complexity:** Simplifies the data model, leading to faster query execution.
- **Optimized Performance:** Can significantly improve performance, especially when dealing with large datasets.
### When to use Single Cross Filter Direction 
- **Hierarchical Relationships:** If your data model has a hierarchical structure, where one table is a parent to another, using a single cross filter direction from the parent to the child can often improve performance.
- **One-way Dependency:** If one table is primarily dependent on data from another, a single cross filter direction from the independent table to the dependent table can be beneficial.
- **Performance Analysis:** Experiment with different cross filter directions to see which one provides the best performance for your specific data model and queries.
### Step to resolve the issue: 
- **Identify the relationship:** Locate the many-to-many relationship causing the performance issue.
- **Edit the relationship:** Open the "Edit Relationship" dialog box.
- **Change cross filter direction:** Select "Single" or "Suppliers Filters Products" to limit the filter flow.
- **Save changes:** Click "OK" to apply the changes to the data model.
# Identifying and reducing cardinality levels 
### Benefits of smaller model size 
- Manage subscription capacity limits 
- Reduce resource contention (memory, processing power, ...)
- Faster queries 
- Efficient refresh resulting in lower report latency
## Identify cardinality 
High cardinality: A large number of distinct values in a column.
*High cardinality slows data models?* It slows down the processing of queries and report loading. 
### 1. Data Model Analysis:
**Explore column properties:** Check the "Distinct Count" value in the column properties *(thousands for smaller dataset, mil/bil for larger dataset)*, the percentage of distinct values compared to the total number of rows. 
	A column that has a lot of repeated values in its range (unique count is low) will have a low level of cardinality. Conversely, a column that has a lot of unique values in its range (unique count is high) will have a high level of cardinality.
**Visualize unique values:** Create a bar chart or card visual to see the distribution of unique values.
**Use DAX functions:** Employ DAX functions like `VALUES` and `COUNTROWS` to calculate distinct values.
### 2. Query Performance:
**Monitor query execution time:** If queries are slow, especially when filtering on high-cardinality columns, it's a strong indicator of high cardinality.
**Use performance analyzers:** Tools like Power BI's Performance Analyzer can help identify bottlenecks related to high cardinality.
### 3. Data Exploration:
**Review data distribution:** Examine the distribution of values within the column. If there are a large number of unique values with low frequencies, it's likely a sign of high cardinality.
**Consider data types:** Numeric columns with high precision (e.g., decimal) often have higher cardinality than integer or categorical columns.
**Examples of High Cardinality Columns:**
- **Customer IDs:** Unique identifiers for individual customers.
- **Product SKUs:** Unique product codes.
- **Timestamps:** Detailed timestamps with high precision.
- **Text columns:** Columns with free-form text input (e.g., customer comments).
## Reducing cardinality
**Strategies for reducing cardinality:**
- **Summarization:** Grouping data by categories to reduce the number of distinct values.
- Significant data reduction could be achieved by grouping by date at month level
- **Changing decimal precision and/or data type:** Reducing the number of decimal places to decrease distinct values. The **Fixed Decimal Number** data type specifies the exact number of decimal digits, mitigating performance issues in calculations. You can update the data types of columns in: _**Report view, Model view, Data view, Query Editor**_
- **DirectQuery Storage Mode:** An effective technique to reduce the model size for larger fact-type tables. This design approach can work well in conjunction with techniques that are used to summarize your data.
**Considerations:**
- **Trade-offs:** Reducing cardinality may result in less granular data.
- **Iterative approach:** Experiment with different techniques to find the best balance between performance and data accuracy.
### Summarization 
[[Create and manage aggregations for good performance.|Create and manage aggregations for good performance.]]
This is similar to moving from a detailed view to a summary view of your data. 
For example, instead of analyzing individual transaction data, you can group them by categories such as product category, order date, or delivery date.
In Power Query window:
- **Select the column:** Choose the column you want to summarize.
- **Group by:** Go to the "Transform" tab and select "Group By."
- **Specify grouping and aggregation:** In the "Group By" window, select the column you want to group by and the aggregation function you want to apply (e.g., sum, count, average).
- **Apply changes:** Click "OK" to apply the changes to your data.